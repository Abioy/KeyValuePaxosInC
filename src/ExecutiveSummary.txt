Project 1 - TCSS 558 (Distributed Computing), UW Tacoma
Kevin Anderson & Daniel Kristiyanto

Assignment Overview
The main purpose of this assignment was to give the student experience in creating a system that communicates with another.  Doing so reveals the fact that communication between machines can be complex and error prone--even in the most simple implementation.  By encouraging students to write the system in a lower level language such as C, forced them to think about much of the complexity that is inherent in distributed system. Luckily, C provides a set of libraries that channel to the system to handle the connection (socket.h, inet.h, netdb.h, in.h, etc.) that abstract some of the communication detail, otherwise the sort 15 day turnaround would have proven impossible. The provided libraries leverage operating system’s capabilities to wrap and format the message, transmit, and deliver it through the network.  Understanding the fundamentals of the TCP and UDP protocols will help us design, develop and troubleshoot distributed systems that leverage a higher level of abstraction, such as RPC.

Technical Impression
To set up the environment, there are a number of steps and information needed. One of the foremost tasks is to set up the socket, and to decide the protocol. While there are a number of protocols available, generally, the decision comes down to whether it is TCP or UDP (SOCK_STREAM or SOCK_DGRAM). Despite of the chosen protocol, the socket also needs to bind to specific port to the machine’s address. This applies to both machines acting as a server and client for UDP, and only machines act as server for TCP. Although socket can be bound to any ports, the trick is not to use pre-defined port that may already used by the system, and to have a convention between the server and client in regard of which port is used to communicate. Generally, port 49152–65535 are generally safe to serve this purpose. Connectionless communication (UDP) can then send and receive messages; however, TCP connections need to establish listen() and accept()/connect() before doing so.

At design time, we each worked on a different protocol, creating two seperate servers and clients (tcp_server.c and udp_server.c for example).  Upon completion we discovered significant similarities in the two files and were able to combine them into one client and one server application, and allowed the user to select which protocol to use.  Further factoring could occur for the socket creation and binding, and will be left as part of the next iteration of the project.

As a side effect of this assignment, we have become more familiar with nc (netcat) for sending messages from the terminal.  This functionality of our Operating System was invaluable during the design and testing of the tcp and udp servers.  Messages could be sent and responses received from our own local machine (or across the LAN) without having to fire up a new client.

Beyond the sending back and forth of messages, another challenges in this project are the message/content processing and the log writing. Although time.h in the system library provides the function to return current time in the machine, the millisecond precision in this library is system specific and is not cross platform.  If the system is to be compiled on a windows machine, a different log.c file must be used.

Lastly, we developed our own KeyValue structure.  This structure uses a simple array for key storage and retrieval.  Because the scope of this project was focused on effective network communication, creating a high performance data structure will be left as future work.  In project two, when the system will be multithreaded, we will be modifying the KeyValue store to handle race conditions.  Performance will be more crucial at that point and a new hash or b-tree solution to the KeyValue store will need to be implemented.
https://github.com/k3a-uw/TCSS558.git